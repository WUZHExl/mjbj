## 一、浏览器安全

### 1.  什么是 XSS 攻击？

> #### （1）概念
>
> XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。
>
> XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。
>
> 攻击者可以通过这种攻击方式可以进行以下操作：
>
> - 获取页面的数据，如DOM、cookie、localStorage；
> - DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
> - 破坏页面结构；
> - 流量劫持（将链接指向某网站）；
>
> #### （2）攻击类型
>
> XSS 可以分为存储型、反射型和 DOM 型：
>
> - 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
> - 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 
> - DOM 型指的通过修改页面的 DOM 节点形成的 XSS。
>
> **1）存储型 XSS 的攻击步骤：**
>
> 1. 攻击者将恶意代码提交到⽬标⽹站的数据库中。
> 2. ⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
> 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
> 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
>
> 这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。
>
> **2）反射型 XSS 的攻击步骤：**
>
> 1. 攻击者构造出特殊的 URL，其中包含恶意代码。
> 2. ⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
> 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
> 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
>
> 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。
>
> 反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。
>
> **3）DOM 型 XSS 的攻击步骤：**
>
> 1. 攻击者构造出特殊的 URL，其中包含恶意代码。
> 2. ⽤户打开带有恶意代码的 URL。
> 3. ⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。
> 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
>
> DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。

### 2. 如何防御 XSS 攻击？

> 可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：
>
> - 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
> - 使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
>
> > 1. CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
> > 2. 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 
>
> - 对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。

### 3. 什么是 CSRF 攻击？

> #### （1）概念
>
> CSRF 攻击指的是**跨站请求伪造攻击**，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。
>
> CSRF 攻击的**本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。**
>
> #### （2）攻击类型
>
> 常见的 CSRF 攻击有三种：
>
> - GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
> - POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
> - 链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

### 4. 如何防御 CSRF 攻击？

> **CSRF 攻击可以使用以下方法来防护：**
>
> - **进行同源检测**，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）
> - **使用 CSRF Token 进行验证**，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。
> - **对 Cookie 进行双重验证**，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。
> - **在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用**，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

### 5. 什么是中间人攻击？如何防范中间人攻击？

> 中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。
>
> 攻击过程如下:
>
> - 客户端发送请求到服务端，请求被中间⼈截获
> - 服务器向客户端发送公钥
> - 中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个**伪造的**公钥，发给客户端
> - 客户端收到伪造的公钥后，⽣成加密hash值发给服务器
> - 中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器
> - 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端

### 6. 有哪些可能引起前端安全的问题?

> 跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；
>
> iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；
>
> 跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击
>
> 恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。

### 7. 网络劫持有哪几种，如何防范？

> ⽹络劫持分为两种:
>
> （1）**DNS劫持**: (输⼊京东被强制跳转到淘宝这就属于dns劫持)
>
> - DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器
> - 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容
>
> （2）**HTTP劫持**: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)
>
> DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。

## 二、进程与线程

### 1. 进程与线程的概念

> 从本质上说，进程和线程都是 CPU 工作时间片的一个描述：
>
> - 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。
> - 线程是进程中的更小单位，描述了执行一段指令所需的时间。
>
> **进程是资源分配的最小单位，线程是CPU调度的最小单位。**
>
> 一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。**进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。**
>
> 如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。
>
> 进程和线程之间的关系有以下四个特点：
>
> **（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。**
>
> **（2）线程之间共享进程中的数据。**
>
> **（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，** 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
>
> **（4）进程之间的内容相互隔离。** 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。

![image-20220308163415793](C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20220308163415793.png)

> 从图中可以看出，最新的 Chrome 浏览器包括：
>
> - 1 个浏览器主进程
> - 1 个 GPU 进程
> - 1 个网络进程
> - 多个渲染进程
> - 多个插件进程
>
> 这些进程的功能：
>
> - **浏览器进程**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
> - **渲染进程**：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
> - **GPU 进程**：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
> - **网络进程**：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
> - **插件进程**：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
>
> 所以，**打开一个网页，最少需要四个进程**：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。
>
> 虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：
>
> - **更高的资源占用**：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
> - **更复杂的体系架构**：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

### 2. 进程和线程的区别

> * 进程可以看做独立应用，线程不能
>
> * 资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
>
> * 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
>
> * 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
>
> * 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

### 3. 浏览器渲染进程的线程有哪些

> 

## 三、浏览器缓存

### 1. 对浏览器的缓存机制的理解

> 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。
>
> - 浏览器每次发起请求，都会`先在浏览器缓存中查找该请求的结果以及缓存标识`
> - 浏览器每次拿到返回的请求结果都会`将该结果和缓存标识存入浏览器缓存中`
>
> 以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是`强制缓存`和`协商缓存`。

> **浏览器缓存的全过程：**
>
> - 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
> - 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；
> - 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
> - 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
> - 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

![image-20220308163814745](C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20220308163814745.png)

> 很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。

### 2. 浏览器资源缓存的位置有哪些？

> 资源缓存的位置一共有 3 种，按优先级从高到低分别是：
>
> 1. **Service Worker：\**Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们\**自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存，并且**缓存是持续性的**。当 Service Worker 没有命中缓存的时候，需要去调用 `fetch` 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。**但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。**
> 2. **Memory Cache：** Memory Cache 就是内存缓存，它的效率最快，**但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。**一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
> 3. **Disk Cache：** Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache **胜在容量和存储时效性上。**在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。**
>
> **Disk Cache：** Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：
>
> - 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
> - 可以推送 `no-cache` 和 `no-store` 的资源
> - 一旦连接被关闭，Push Cache 就被释放
> - 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
> - Push Cache 中的缓存只能被使用一次
> - 浏览器可以拒绝接受已经存在的资源推送
> - 可以给其他域名推送资源

### 3. 协商缓存和强缓存的区别

> #### （1）强缓存
>
> **使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。**
>
> > 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`，其中Cache-Control优先级比Expires高。
> >
> > 强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：
> >
> > 1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。
> > 2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
> > 3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果
>
> 强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。
>
> （1）**服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。**在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。
>
> （2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，
>
> `Cache-Control`可设置的字段：
>
> - `public`：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；
> - `private`：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
> - `no-cache`：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
> - `no-store`：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
> - `max-age=`：设置缓存的最大有效期，单位为秒；
> - `s-maxage=`：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；
> - `max-stale[=]`：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。
>
> 一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。
>
> **no-cache和no-store很容易混淆：**
>
> - no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
> - no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。
>
> #### （2）协商缓存
>
> 如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。
>
> > **协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，**同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：`Last-Modified / If-Modified-Since` 和 `Etag / If-None-Match`，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：
> >
> > 1. 协商缓存生效，返回304
> > 2. 协商缓存失效，返回200和请求结果结果
>
> 上面已经说到了，命中协商缓存的条件有两个：
>
> - `max-age=xxx` 过期了
> - 值为`no-cache`
>
> 使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。
>
> 协商缓存也可以通过两种方式来设置，分别是 http 头信息中的**Etag** 和**Last-Modified**属性。
>
> （1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。
>
> （2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。
>
> 当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。
>
> **总结：**
>
> 强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

### 4. 为什么需要浏览器缓存？

> 对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。
>
> 所谓的**浏览器缓存**指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。
>
> 使用浏览器缓存，有以下优点：
>
> - 减少了服务器的负担，提高了网站的性能
> - 加快了客户端网页的加载速度
> - 减少了多余网络数据传输

### 5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？

> **点击刷新按钮或者按 F5：** 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。
>
> **用户按 Ctrl+F5（强制刷新）：** 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。
>
> 地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

## 四、浏览器组成

### 1. 对浏览器的理解

> 浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。
>
> HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。
>
> 浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。
>
> - shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。
> - 内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。

### 2. 对浏览器内核的理解

> 浏览器内核主要分成两部分：
>
> - 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。
> - JS 引擎：解析和执行 javascript 来实现网页的动态效果。
>
> 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。

### 3. 浏览器的主要组成部分

> - **⽤户界⾯** 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。
> - **浏览器引擎** 在⽤户界⾯和呈现引擎之间传送指令。
> - **呈现引擎** 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
> - **⽹络** ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。
> - **⽤户界⾯后端** ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。
> - **JavaScript 解释器**。⽤于解析和执⾏ JavaScript 代码。
> - **数据存储** 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。
>
> 值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。

## 五、浏览器渲染原理

### 1. 浏览器的渲染过程

> 浏览器渲染主要有以下步骤：
>
> - 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
> - 然后对 CSS 进行解析，生成 CSSOM 规则树。
> - **根据 DOM 树和 CSSOM 规则树构建渲染树。**渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
> - 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
> - 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

### 2. 浏览器渲染优化

> **1）针对JavaScript：** JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：
>
> （1）尽量将JavaScript文件放在body的最后
>
> （2） body中间尽量不要写`<script>`标签
>
> （3）`<script>`标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：
>
> - **script** 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
> - **async** 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；
> - **defer** 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。
>
> **（2）针对CSS：\**使用CSS有三种方式：使用\**link、@import、内联样式**，其中link和@import都是导入外部样式。它们之间的区别：
>
> - **link**：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码
> - **@import**：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)
> - **style**：GUI直接渲染
>
> 外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。
>
> 所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。
>
> **（3）针对DOM树、CSSOM树：** 可以通过以下几种方式来减少渲染的时间：
>
> - HTML文件的代码层级尽量不要太深
> - 使用语义化的标签，来避免不标准语义化的特殊处理
> - 减少CSSD代码的层级，因为选择器是从左向右进行解析的
>
> **（4）减少回流与重绘：**
>
> - 操作DOM时，尽量在低层级的DOM节点进行操作
> - 不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局
> - 使用CSS的表达式
> - 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
> - 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
> - 避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
> - 将元素先设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
> - 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**。
>
> 浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**
>
> **浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**
>
> 将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

### 3.什么情况会阻塞渲染？

> 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。
>
> 当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。

## 六、浏览器本地存储

### 1. 浏览器本地存储方式及使用场景

> #### （1）Cookie
>
> Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。
>
> **Cookie的特性：**
>
> - Cookie一旦创建成功，名称就无法修改
> - Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie
> - 每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb
> - 有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的
> - Cookie在请求一个新的页面的时候都会被发送过去
>
> 如果需要域名之间跨域共享Cookie，有两种方法：
>
> 1. 使用Nginx反向代理
> 2. 在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId
>
> **Cookie的使用场景：**
>
> - 最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。
> - 可以用来统计页面的点击次数
>
> #### （2）LocalStorage
>
> LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。
>
> **LocalStorage的优点：**
>
> - 在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息
> - LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在
> - 仅储存在本地，不像Cookie那样每次HTTP请求都会被携带
>
> **LocalStorage的缺点：**
>
> - 存在浏览器兼容问题，IE8以下版本的浏览器不支持
> - 如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage
> - LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问
>
> **LocalStorage的常用API：**
>
> ```javascript
> // 保存数据到 localStorage
> localStorage.setItem('key', 'value');
> 
> // 从 localStorage 获取数据
> let data = localStorage.getItem('key');
> 
> // 从 localStorage 删除保存的数据
> localStorage.removeItem('key');
> 
> // 从 localStorage 删除所有保存的数据
> localStorage.clear();
> 
> // 获取某个索引的Key
> localStorage.key(index)
> ```
> 
>**LocalStorage的使用场景：**
> 
>- 有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可
> - 在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中
> 
>#### （3）SessionStorage
> 
>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。
> 
>**SessionStorage与LocalStorage对比：**
> 
>- SessionStorage和LocalStorage都在**本地进行数据存储**；
> - SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage**只有在同一浏览器的同一窗口下才能够共享**；
> - LocalStorage和SessionStorage**都不能被爬虫爬取**；
> 
>**SessionStorage的常用API：**
> 
>```javascript
> // 保存数据到 sessionStorage
> sessionStorage.setItem('key', 'value');
> 
> // 从 sessionStorage 获取数据
> let data = sessionStorage.getItem('key');
> 
> // 从 sessionStorage 删除保存的数据
> sessionStorage.removeItem('key');
> 
> // 从 sessionStorage 删除所有保存的数据
> sessionStorage.clear();
> 
> // 获取某个索引的Key
> sessionStorage.key(index)
> ```
> 
> **SessionStorage的使用场景**
>
> - 由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。

### 2. Cookie有哪些字段，作用分别是什么

> **Cookie由以下字段组成：**
>
> - **Name**：cookie的名称
> - **Value**：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；
> - **Size**： cookie的大小
> - **Path**：可以访问此cookie的页面路径。 比如domain是abc.com，path是`/test`，那么只有`/test`路径下的页面可以读取此cookie。
> - **Secure**： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。
> - **Domain**：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。
> - **HTTP**： 该字段包含`HTTPOnly` 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过`document.cookie`属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。
> - **Expires/Max-size** ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。
>
> **总结：** 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。

### 3. 前端储存的⽅式有哪些？

> cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；
>
> localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；
>
> sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；
>
> Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；
>
> IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。

### 4.IndexedDB有哪些特点？

> IndexedDB 具有以下特点：
>
> - **键值对储存**：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
> - **异步**：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
> - **支持事务**：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
> - **同源限制：** IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
> - **储存空间大**：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
> - **支持二进制储存**：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。

## 七、浏览器同源策略

### 1. 什么是同源策略

> 跨域问题其实就是浏览器的同源策略造成的。
>
> > 同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：**协议**、**端口号**、**域名**必须一致。
>
> 下表给出了与 URL [store.company.com/dir/page.ht…](https://link.juejin.cn/?target=http%3A%2F%2Fstore.company.com%2Fdir%2Fpage.html) 的源进行对比的示例:
>
> ![image-20220308183726473](C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20220308183726473.png)

> **同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。**
>
> **同源政策主要限制了三个方面：**
>
> - 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
> - 当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
> - 当前域下 ajax 无法发送跨域请求。
>
> 同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

### 2. 如何解决跨越问题

> #### （1）CORS
>
> 下面是MDN对于CORS的定义：
>
> > 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。
>
> CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现**CORS的关键就是服务器，只要服务器实现了CORS请求**，就可以跨源通信了。
>
> 浏览器将CORS分为**简单请求**和**非简单请求**：
>
> 简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：
>
> **1）请求方法是以下三种方法之一：**
>
> - HEAD
> - GET
> - POST
>
> **2）HTTP的头信息不超出以下几种字段：**
>
> - Accept
> - Accept-Language
> - Content-Language
> - Last-Event-ID
> - Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
>
> 若不满足以上条件，就属于非简单请求了。
>
> **（1）简单请求过程：**
>
> 对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：
>
> ```javascript
> Access-Control-Allow-Origin: http://api.bob.com  // 和Orign一直
> Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie
> Access-Control-Expose-Headers: FooBar   // 指定返回其他字段的值
> Content-Type: text/html; charset=utf-8   // 表示文档类型
> ```
> 
>如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。
> 
>**在简单请求中，在服务器内，至少需要设置字段：**`Access-Control-Allow-Origin`
> 
>**（2）非简单请求过程**
> 
>非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，**称为预检请求**。
> 
>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。
> 
>预检请求使用的**请求方法是OPTIONS**，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：
> 
>- **Access-Control-Request-Method**：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。
> - **Access-Control-Request-Headers**： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。
> 
>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。
> 
>服务器回应的CORS的字段如下：
> 
>```javascript
> Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址
> Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法
> Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段
> Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie
> Access-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒
> ```
> 
> 只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。
>
> **在非简单请求中，至少需要设置以下字段：**
>
> ```javascript
>'Access-Control-Allow-Origin'  
> 'Access-Control-Allow-Methods'
> 'Access-Control-Allow-Headers'
> ```
> 
> ##### 减少OPTIONS请求次数：
> 
>OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。
> 
>##### CORS中Cookie相关问题：
> 
>在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：
> 
>- 在请求中设置 `withCredentials`
> 
>默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.
> 
>```javascript
> // 原生 xml 的设置方式
>var xhr = new XMLHttpRequest();
> xhr.withCredentials = true;
> // axios 设置方式
> axios.defaults.withCredentials = true;
> ```
> 
> - Access-Control-Allow-Credentials 设置为 true
> - Access-Control-Allow-Origin 设置为非 `*`
> 
>#### （2）JSONP
> 
> **jsonp**的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。 1）原生JS实现：
>
> ```javascript
><script>
>     var script = document.createElement('script');
>    script.type = 'text/javascript';
>     // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
>     script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
>     document.head.appendChild(script);
>     // 回调执行函数
>     function handleCallback(res) {
>         alert(JSON.stringify(res));
>     }
>  </script>
> ```
> 
> 服务端返回如下（返回时即执行全局函数）：
> 
> ```javascript
>handleCallback({"success": true, "user": "admin"})
> ```
>
> 2）Vue axios实现：
> 
> ```javascript
>this.$http = axios;
> this.$http.jsonp('http://www.domain2.com:8080/login', {
>    params: {},
>     jsonp: 'handleCallback'
> }).then((res) => {
>     console.log(res); 
> })
> ```
> 
> 后端node.js代码：
> 
> ```javascript
>var querystring = require('querystring');
> var http = require('http');
>var server = http.createServer();
> server.on('request', function(req, res) {
>     var params = querystring.parse(req.url.split('?')[1]);
>     var fn = params.callback;
>     // jsonp返回设置
>     res.writeHead(200, { 'Content-Type': 'text/javascript' });
>     res.write(fn + '(' + JSON.stringify(params) + ')');
>     res.end();
> });
> server.listen('8080');
> console.log('Server is running at port 8080...');
> ```
> 
> **JSONP的缺点：**
> 
> - 具有局限性， 仅支持get方法
>- 不安全，可能会遭受XSS攻击
> 
>#### （3）postMessage 跨域
> 
> postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
>
> - 页面和其打开的新窗口的数据传递
>- 多窗口之间消息传递
> - 页面与嵌套的iframe消息传递
>- 上面三个场景的跨域数据传递
> 
> 用法：postMessage(data,origin)方法接受两个参数：
> 
> - **data**： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
>- **origin**： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。
> 
>1）a.html：(domain1.com/a.html)
> 
> ```javascript
><iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
> <script>       
>    var iframe = document.getElementById('iframe');
>     iframe.onload = function() {
>         var data = {
>             name: 'aym'
>         };
>         // 向domain2传送跨域数据
>         iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
>     };
>     // 接受domain2返回数据
>     window.addEventListener('message', function(e) {
>         alert('data from domain2 ---> ' + e.data);
>     }, false);
> </script>
> ```
> 
> 2）b.html：(domain2.com/b.html)
> 
> ```javascript
><script>
>     // 接收domain1的数据
>    window.addEventListener('message', function(e) {
>         alert('data from domain1 ---> ' + e.data);
>         var data = JSON.parse(e.data);
>         if (data) {
>             data.number = 16;
>             // 处理后再发回domain1
>             window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
>         }
>     }, false);
> </script>
> ```
> 
> #### （4）nginx代理跨域
> 
> nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。
>
> 1）nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。
>
> ```http
>location / {
>   add_header Access-Control-Allow-Origin *;
>}
> ```
> 
> 2）nginx反向代理接口跨域 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。 实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。
> 
> nginx具体配置：
>
> ```javascript
>#proxy服务器
> server {
>    listen       81;
>     server_name  www.domain1.com;
>     location / {
>         proxy_pass   http://www.domain2.com:8080;  #反向代理
>         proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
>         index  index.html index.htm;
>         # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
>         add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
>         add_header Access-Control-Allow-Credentials true;
>     }
> }
> ```
> 
> #### （5）nodejs 中间件代理跨域
> 
> node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。
>
> **1）非vue框架的跨域** 使用node + express + http-proxy-middleware搭建一个proxy服务器。
>
> - 前端代码：
>
> ```javascript
>var xhr = new XMLHttpRequest();
> // 前端开关：浏览器是否读写cookie
>xhr.withCredentials = true;
> // 访问http-proxy-middleware代理服务器
> xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);
> xhr.send();
> ```
> 
> - 中间件服务器代码：
> 
> ```javascript
>var express = require('express');
> var proxy = require('http-proxy-middleware');
>var app = express();
> app.use('/', proxy({
>     // 代理跨域目标接口
>     target: 'http://www.domain2.com:8080',
>     changeOrigin: true,
>     // 修改响应头信息，实现跨域并允许带cookie
>     onProxyRes: function(proxyRes, req, res) {
>         res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
>         res.header('Access-Control-Allow-Credentials', 'true');
>     },
>     // 修改响应信息中的cookie域名
>     cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
> }));
> app.listen(3000);
> console.log('Proxy server is listen at port 3000...');
> ```
> 
> **2）vue框架的跨域**
> 
> node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。
>
> webpack.config.js部分配置：
>
> ```javascript
>module.exports = {
>     entry: {},
>    module: {},
>     ...
>     devServer: {
>         historyApiFallback: true,
>         proxy: [{
>             context: '/login',
>             target: 'http://www.domain2.com:8080',  // 代理跨域目标接口
>             changeOrigin: true,
>             secure: false,  // 当代理某些https服务报错时用
>             cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
>         }],
>         noInfo: true
>     }
> }
> ```
> 
> #### （6）document.domain + iframe跨域
> 
> 此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1）父窗口：(domain.com/a.html)
>
> ```javascript
><iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
> <script>
>    document.domain = 'domain.com';
>     var user = 'admin';
> </script>
> ```
> 
> 1）子窗口：(child.domain.com/a.html)
> 
> ```javascript
><script>
>     document.domain = 'domain.com';
>    // 获取父窗口中变量
>     console.log('get js data from parent ---> ' + window.parent.user);
> </script>
> ```
> 
> #### （7）location.hash + iframe跨域
> 
> 实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
>
> 具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。
>
> 1）a.html：(domain1.com/a.html)
>
> ```javascript
><iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
> <script>
>    var iframe = document.getElementById('iframe');
>     // 向b.html传hash值
>     setTimeout(function() {
>         iframe.src = iframe.src + '#user=admin';
>     }, 1000);
> 
>     // 开放给同域c.html的回调方法
>     function onCallback(res) {
>         alert('data from c.html ---> ' + res);
>         }
> </script>
> ```
> 
> 2）b.html：(.domain2.com/b.html)
> 
> ```
><iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
> <script>
>    var iframe = document.getElementById('iframe');
>     // 监听a.html传来的hash值，再传给c.html
>     window.onhashchange = function () {
>         iframe.src = iframe.src + location.hash;
>     };
> </script>
> ```
> 
> 3）c.html：([www.domain1.com/c.html](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fwww.domain1.com%2Fc.html))
> 
> ```javascript
><script>
>     // 监听b.html传来的hash值
>    window.onhashchange = function () {
>         // 再通过操作同域a.html的js回调，将结果传回
>         window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
>     };
> </script>
> ```
> 
> #### （8）window.name + iframe跨域
> 
> window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
>
> 1）a.html：(domain1.com/a.html)
>
> ```javascript
>var proxy = function(url, callback) {
>     var state = 0;
>    var iframe = document.createElement('iframe');
>     // 加载跨域页面
>     iframe.src = url;
>     // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
>     iframe.onload = function() {
>         if (state === 1) {
>             // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
>             callback(iframe.contentWindow.name);
>             destoryFrame();
>         } else if (state === 0) {
>             // 第1次onload(跨域页)成功后，切换到同域代理页面
>             iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
>             state = 1;
>         }
>     };
>     document.body.appendChild(iframe);
>     // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
>     function destoryFrame() {
>         iframe.contentWindow.document.write('');
>         iframe.contentWindow.close();
>         document.body.removeChild(iframe);
>     }
> };
> // 请求跨域b页面数据
> proxy('http://www.domain2.com/b.html', function(data){
>     alert(data);
> });
> ```
> 
> 2）proxy.html：(domain1.com/proxy.html)
> 
> 中间代理页，与a.html同域，内容为空即可。 3）b.html：(domain2.com/b.html)
>
> ```javascript
><script>    
>     window.name = 'This is domain2 data!';
></script>
> ```
> 
> 通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。
> 
> #### （9）WebSocket协议跨域
>
> WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
>
> 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。
>
> 1）前端代码：
>
> ```javascript
><div>user input：<input type="text"></div>
> <script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
><script>
> var socket = io('http://www.domain2.com:8080');
> // 连接成功处理
> socket.on('connect', function() {
>     // 监听服务端消息
>     socket.on('message', function(msg) {
>         console.log('data from server: ---> ' + msg); 
>     });
>     // 监听服务端关闭
>     socket.on('disconnect', function() { 
>         console.log('Server socket has closed.'); 
>     });
> });
> document.getElementsByTagName('input')[0].onblur = function() {
>     socket.send(this.value);
> };
> </script>
> ```
> 
> 2）Nodejs socket后台：
> 
> ```javascript
>var http = require('http');
> var socket = require('socket.io');
>// 启http服务
> var server = http.createServer(function(req, res) {
>     res.writeHead(200, {
>         'Content-type': 'text/html'
>     });
>     res.end();
> });
> server.listen('8080');
> console.log('Server is running at port 8080...');
> // 监听socket连接
> socket.listen(server).on('connection', function(client) {
>     // 接收信息
>     client.on('message', function(msg) {
>         client.send('hello：' + msg);
>         console.log('data from client: ---> ' + msg);
>     });
>     // 断开处理
>     client.on('disconnect', function() {
>         console.log('Client socket has closed.'); 
>     });
> });
> ```

### 3. 正向代理和反向代理的区别

> - **正向代理：**
>
> 客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。
>
> - **反向代理：**
>
> 服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。
>
> 正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。

### 4. Nginx的概念及其工作原理

> Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。
>
> 传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。
>
> Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。

## 八、浏览器事件机制

### 1. 事件是什么？事件模型？

> 事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。
>
> 事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：
>
> - **DOM0 级事件模型**，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。
> - **IE 事件模型**，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。
> - **DOM2 级事件模型**，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

### 2. 如何阻止事件冒泡

> - 普通浏览器使用：event.stopPropagation()
> - IE浏览器使用：event.cancelBubble = true;

### 3. 对事件委托的理解

> #### （1）事件委托的概念
>
> 事件委托本质上是利用了**浏览器事件冒泡**的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。
>
> 使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。
>
> #### （2）事件委托的特点
>
> - **减少内存消耗**
>
> 如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：
>
> ```html
> <ul id="list">
>   <li>item 1</li>
>   <li>item 2</li>
>   <li>item 3</li>
>   ......
>   <li>item n</li>
> </ul>
> ```
>
> 如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。
>
> - **动态绑定事件**
>
> 给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。
>
> ```javascript
> // 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：
> // 给父层元素绑定事件
> document.getElementById('list').addEventListener('click', function (e) {
>   // 兼容性处理
>   var event = e || window.event;
>   var target = event.target || event.srcElement;
>   // 判断是否匹配目标元素
>   if (target.nodeName.toLocaleLowerCase === 'li') {
>     console.log('the content is: ', target.innerHTML);
>   }
> });
> ```
>
> 在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；
>
> #### （3）局限性
>
> 当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。
>
> 当然事件委托不是只有优点，它也是有**缺点**的，事件委托会影响页面性能，主要影响因素有：
>
> - 元素中，绑定事件委托的次数；
> - 点击的最底层元素，到绑定事件元素之间的`DOM`层数；
>
> 在必须使用事件委托的地方，可以进行如下的处理：
>
> - 只在必须的地方，使用事件委托，比如：`ajax`的局部刷新区域
> - 尽量的减少绑定的层级，不在`body`元素上，进行绑定
> - 减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。

### 4. 事件委托的使用场景

> 场景：给页面的所有的a标签添加click事件，代码如下：
>
> ```javascript
> document.addEventListener("click", function(e) {
> 	if (e.target.nodeName == "A")
> 		console.log("a");
> }, false);
> ```
>
> 但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。
>
> 这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：
>
> ```javascript
> document.addEventListener("click", function(e) {
> 	var node = e.target;
> 	while (node.parentNode.nodeName != "BODY") {
> 		if (node.nodeName == "A") {
> 			console.log("a");
> 			break;
> 		}
> 		node = node.parentNode;
> 	}
> }, false);
> ```

### 5. 同步和异步的区别

> **同步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。
>
> **异步**指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。

### 6. 对事件循环(Event Loop)的理解

> JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。整个执行过程，我们称为事件循环过程。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。
>
> macro-task大概包括：
>
> - script(整体代码)
> - setTimeout
> - setInterval
> - setImmediate
> - I/O
> - UI render(渲染)
>
> micro-task大概包括:
>
> - process.nextTick
> - Promise
> - Async/Await(实际就是promise)
> - MutationObserver(html5新特性)

![image-20220308191708900](C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20220308191708900.png)

> Event Loop 执行顺序如下所示：
>
> - 首先执行同步代码，这属于宏任务
> - 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
> - 执行所有微任务
> - 当执行完所有微任务后，如有必要会渲染页面
> - 然后开始下一轮 Event Loop，执行宏任务中的异步代码
>
> 总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

### 7. 宏任务和微任务分别有哪些

> * 微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。
>
> * 宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。

### 8. 什么是执行栈

> 可以把执行栈认为是一个存储函数调用的**栈结构**，遵循先进后出的原则。
>
> 当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，`foo` 函数后执行，当执行完毕后就从栈中弹出了。

### 9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？

> Node 中的 Event Loop 和浏览器中的是完全不相同的东西。
>
> Node 的 Event Loop 分为 6 个阶段，它们会按照**顺序**反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。

###  10. 从输入URL到页面加载的全过程

> 首先在浏览器中输入URL
>
> 查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。
>
> - 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
> - 操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；
> - 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
> - ISP缓存：若上述均失败，继续向ISP搜索。
>
> DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。`DNS服务器是基于UDP的，因此会用到UDP协议`。
>
> 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接
>
> 发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器
>
> 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
>
> 关闭TCP连接：通过四次挥手释放TCP连接
>
> 浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：
>
> - 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
> - 构建CSS规则树：生成CSS规则树（CSS Rule Tree）
> - 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
> - 布局（Layout）：计算出每个节点在屏幕中的位置
> - 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。
>
> ![浏览器渲染流程图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)
>
> JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
>
> - 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。
> - 加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译
> - 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。
> - 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。

### 11.重绘与重排

> ### 浏览器重绘与重排的区别？
>
> - `重排/回流（Reflow）`：当`DOM`的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。
> - `重绘(Repaint)`: 当一个元素的**外观发生改变，但没有改变布局**,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变
>
> 单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分
>
> 重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。
>
> 『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。
>
> ### 如何触发重排和重绘？
>
> 任何改变用来构建渲染树的信息都会导致一次重排或重绘：
>
> - 添加、删除、更新DOM节点
> - 通过display: none隐藏一个DOM节点-触发重排和重绘
> - 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化
> - 移动或者给页面中的DOM节点添加动画
> - 添加一个样式表，调整样式属性
> - 用户行为，例如调整窗口大小，改变字号，或者滚动。
>
> ### 如何避免重绘或者重排？
>
> 1. `集中改变样式`，不要一条一条地修改 DOM 的样式。
>
> 2. 不要把 DOM 结点的属性值放在循环里当成循环里的变量。
>
> 3. 为动画的 HTML 元件使用 `fixed` 或 `absoult` 的 `position`，那么修改他们的 CSS 是不会 reflow 的。
>
> 4. 不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
>
> 5. 尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大
>
> 6. 动画开始`GPU`加速，`translate`使用`3D`变化
>
> 7. 提升为合成层
>
>    将元素提升为合成层有以下优点：
>
>    - 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
>    - 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
>    - 对于 transform 和 opacity 效果，不会触发 layout 和 paint
>
>    提升合成层的最好方式是使用 CSS 的 will-change 属性：
>
>    ```css
>    #target {
>      will-change: transform;
>    }
>    ```

## 九、浏览器垃圾回收机制

### 1. 哪些操作会造成内存泄漏？

> * 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
>
> * 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
>
> * 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
>
> * 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。